---
title: "Easy to Use and Share Data Labels in R with Dictionaries"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Easy to Use and Share Data Labels in R with Dictionaries}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(labeler)
```

## Labelled data in R

Historically, software like SPSS, SAS or Stata have worked with labelled data. The closest function in R base corresponds to factors, which actually work in reverse, assigning values to text variables with few distinct values.

Being able to work with labelled data is one of the features that R users who come from the previously mentioned systems miss the most. Especially when processing survey and census data.

In the R ecosystem there are 3 fundamental packages for working with labelled data `haven`, `labelled` and `sjlabelled`[^1]. However, these packages work similarly, expecting pre-labelled data or manual label assignment for each variable.

[^1]: See <https://www.pipinghotdata.com/posts/2020-12-23-leveraging-labelled-data-in-r/>

Manual labelling becomes cumbersome with numerous variables, especially as some R operations remove attributes, requiring repeated label assignments. 

> **`labeler` offers a new scheme based on dictionaries and delayed, semi-automated label application.**

Excelente, con esta nueva función `gen_Dict()`, la sección de *The dictionary* del vignette se puede mejorar aún más, incorporando la capacidad de generar diccionarios automáticamente a partir de dataframes etiquetados. Aquí te propongo la versión revisada de esa sección:

## The dictionary

The dictionary is a `Dict` object created with the `Dict()` function. It contains a list of variables, each a list with:

* **label:** A character string describing the variable (can include a short name before "||" and a long description after).
* **labels:** A named vector or list defining value labels.
* **dtype:** (Optional) A character string specifying the desired data type.

A valid dictionary is created as follows:

```{r}
dict <- Dict(
  GENDER = list(
    label = "Gender || Gender of the person",
    labels = c("Man" = 1, "Woman" = 2),
    dtype = "integer"
  ),
  AGE = list(
    label = "Age || Age of the person",
    dtype = "integer"
  ),
  SEX = list(
    label = "Sex || Gender of the person",
    labels = c("Man" = 1, "Woman" = 2),
    dtype = "integer"
  ),
  Married = list(
    label = "Marital Status || Indicates whether or not the person is married",
    labels = c("No" = 0, "Yes" = 1),
    dtype = "integer"
  ),
  metadata = list(name = "mydata")
)

dict
```

### Building a dictionary automatically

If you're working with an already labelled dataset, `labeler` can automatically generate a dictionary using the `gen_Dict()` function. This simplifies the process considerably.

```{r}
lbl_df <- set_Dict(lbl_df, lbl_df_dict)
str(lbl_df)
```

```{r}
generated_dict <- gen_Dict(lbl_df) 
str(generated_dict)
```

### Converting from old dictionaries

You can convert old dictionaries to the new format using `as.Dict()`. However, linked labels (`link::`) are not supported and will be ignored with a warning.

```{r}
old_dict <- list(
  GENDER = list(
    lab = "Gender of the person",
    labs = c("Man" = 1, "Woman" = 2)
  ),
  AGE = list(
    lab = "Age of the person"
  ),
  SEX = list(
    lab = "link::GENDER",  # This will generate a warning
    labs = "link::GENDER" # This will generate a warning
  )
)

new_dict <- as.Dict(old_dict, metadata = list(name = "converted_dict"))
new_dict
```

### Browsing the dictionary

Use `dict_browser()` to interactively explore the dictionary:

```{r eval=FALSE}
dict_browser(dict) 
```

## Setting the labels

`set_Dict()` applies the dictionary to a data frame.

```{r}
mydata <- data.frame(
  GENDER = c(rep(1, 5), rep(2, 5)),
  AGE = c(seq(1, 30, 3)),
  SEX = c(rep(1, 5), rep(2, 5)),
  Married = c(rep(0, 4), rep(1, 6))
)

labeled_data <- set_Dict(mydata, dict)
str(labeled_data)
```

Subset application:

```{r}
labeled_data_subset <- set_Dict(mydata, dict, subset = c("GENDER"))
str(labeled_data_subset)

labeled_data_case_insensitive <- set_Dict(mydata, dict, dtypes = FALSE) # dtypes are applied in set_Dict, not in with_Dict
str(labeled_data_case_insensitive)
```

## Using the labels

`with_Dict()` converts labelled values to their labels and/or replaces column names with variable labels:

```{r}
# Convert values to labels
data_with_labels <- with_Dict(mydata, dict, use_labels = TRUE)
print(data_with_labels)

# Replace column names with labels
data_with_label_names <- with_Dict(mydata, dict, use_label = TRUE, dtypes = FALSE) 
print(data_with_label_names)

# Combine both operations
data_with_both <- with_Dict(mydata, dict, use_label = TRUE, use_labels = TRUE, dtypes = FALSE)
print(data_with_both)
```

Piping with dplyr:

```{r}
mydata %>% 
  set_Dict(dict, label_type = "name") %>%
  dplyr::group_by(GENDER, Married) %>% 
  dplyr::count() %>% 
  with_Dict(use_labels = TRUE)
```